#!/usr/bin/env sh

#Validation section
verify_name() {
	if echo "$1" | grep -qE '^[0-9a-zA-Z_]+$'; then
		return 0
	else
		echo "ILLEGAL VARIABLE: Must only contain [0-9a-zA-Z_]" >&2
		return 1;
	fi
}
verify_addr() {
	if echo "$1" | grep -qE '^[0-9a-fA-F]+$'; then
		return 0
	else
		echo "ILLEGAL POINTER: Must only contain [0-9a-fA-F]"
		return 1;
	fi
}
ask_confirm() {
	echo -n "$1 [y/N] " && read -r action && [ "$action" != "y" ]
	return $?
}

#Raw data access section
#Require variables: PID
read_wrapper() {
	dd if="/proc/$PID/mem" status=none bs=1 count=$2 skip=$1
}
#Require variables: PID
write_wrapper() {
	dd of="/proc/$PID/mem" status=none bs=1 count=$2 seek=$1 conv=notrunc
}

#Pretty data access section
#Require variables: ORDER, DATA?
value_order() {
	case $ORDER in
		s|string)          echo "$(cat)" ;;
		s16|string16)      echo "$(iconv -f UTF16LE -t UTF8 2>/dev/null)" ;;
		s16r|string16rev)  echo "$(iconv -f UTF16BE -t UTF8 2>/dev/null)" ;;
		b|binary)          echo "$(xxd)" ;;
		i|int)             echo "$((0x$(xxd -p | fold -b2 | tac | tr -d '\n')))" ;;
		ir|intrev)         echo "$((0x$(xxd -p)))" ;;
		f|file)            cat >>"$DATA" ;;
		*) echo "ILLEGAL ORDER: Order $ORDER not recognised" >&2 ;;
	esac
}
#Require variables: ORDER, DATA
value_deorder() {
	case $ORDER in
		s|string)          printf "%s" "$DATA" ;;
		s16|string16)      printf "%s" "$DATA" | iconv -f UTF8 -t UTF16LE 2>/dev/null ;;
		s16r|string16rev)  printf "%s" "$DATA" | iconv -f UTF8 -t UTF16BE 2>/dev/null ;;
		b|binary)          printf "%s" "$DATA" | xxd -p -r ;;
		i|int)             printf "%0*X" "$((($(printf "%X" "$DATA" | wc -c) + 1) & ~1))" "$DATA" | fold -b2 | tac | tr -d '\n' | xxd -p -r ;;
		ir|intrev)         printf "%0*X" "$((($(printf "%X" "$DATA" | wc -c) + 1) & ~1))" "$DATA" | xxd -p -r ;;
		f|file)            cat <"$DATA" ;;
		*) echo "ILLEGAL ORDER: Order $ORDER not recognised" >&2 ;;
	esac
}
#Require variables: ORDER, SIZE
value_resize() { #TODO change
	case $ORDER in
		s16*|string16*) echo "$((SIZE * 2))" ;;
		b|binary)       echo "$((SIZE / 2))" ;;
		*)              echo "$((SIZE))" ;;
	esac
}
#Require variables: ORDER, PID, ADDR, SIZE, DATA?, OFFSET?
read_pretty() {
	[ -z "$ADDR" ] && return
	read_wrapper "$((0x$ADDR + ${OFFSET:-0}))" "$(value_resize)" | value_order
}
#Require variables: ORDER, PID, ADDR, SIZE, DATA, OFFSET? 
write_pretty() {
	[ -z "$ADDR" ] && return
	value_deorder | write_wrapper "$((0x$ADDR + ${OFFSET:-0}))" "$(value_resize)"
}

#User documentation section
show_usage() {
	echo "Usage: $0 <pid>";
	exit 1
}
show_docs() {
	echo "$0: General syntax: <cmd>[-order] <var> [data...]"
  echo "Commands:"
	echo "  h|help"
  echo "    Display this"
	echo "  a|attach <pid>"
  echo "    Set the global PID to a new value"
	echo "  m|maps [flags...]"
  echo "    Display memory maps in the global PID"
	echo "  f|find <var> <data> [flags...]"
  echo "    Search for data in the global PID"
	echo "  p|point <var> <addr>"
  echo "    Manually store address to a variable. Its PID is reset to global"
	echo "  v|view <var>"
  echo "    View the address/PID stored in a variable"
	echo "  l|loop <var> <size> <data> [interval]  Set data to a pointer on loop in background"
	echo "  s|set <var> <size> <data> [offset]"
  echo "    Set data to a pointer"
	echo "  g|get <var> <size> [data] [offset]"
  echo "    Get data from a pointer"
	echo "Orders:"
	echo "  -s|-string        The data is sent-as-is string"
	echo "  -s16|-string16    The target is a UTF16LE string"
	echo "  -s16r|-string16r  The target is a UTF16BE string"
	echo "  -b|-binary        The data is hexadecimal string"
	echo "  -i|-int           The target is an LE integer"
	echo "  -ir|-intrev       The target is an BE integer"
	echo "  -f|-file          The data is taken from a file"
	echo "Flags:"
	echo "  m-<mode>   Only display maps with specific access (eg. 'm-rw-p', 'm-r--p', 'm---xs')"
	echo "  n-<name>   Only display maps with specific name (eg. 'n-[heap]', 'n-', 'n-/lib/somelib.so')"
	echo "  s-<size>   Skip maps larged than <size> (eg. 's-0x12345678', 's-1234')"
	echo "  sa-<size>  Ask if processing maps larger than <size>"
	echo "Notes:"
	echo "  'data' in 'get' is required, if '-file' order is used"
	echo "  'addr' is provided without '0x'"
	echo "  'var' can contain [0-9a-zA-z_]"
	echo "  'size' means 'size in input bytes', or if integer order is used, the size of integer"
}

#Variable manipulation section
#All require variables: VAR
save_list() {
	if verify_name "$VAR"; then
		local i=0
		for addr in $@; do
			if verify_addr "$addr"; then
				eval "com_${VAR}_${i}_addr=$addr; com_${VAR}_${i}_pid=$GLOBAL_PID"
			fi
			i=$((i + 1))
		done
		if [ $i -ne 0 ]; then
			eval "com_${VAR}_size=$i"
			echo "SUCCESS: Saved state: Into array '$VAR', count $i"
		fi
	fi
}
purge_list() {
	if verify_name "$VAR"; then
		eval "local size=\$com_${VAR}_size"
		for i in $(seq 0 $size ); do
			unset "com_${VAR}_${i}_addr" "com_${VAR}_${i}_pid"
		done
		unset "com_${VAR}_size"
	fi
}
save_state() {
	if verify_name "$VAR" && verify_addr "$1"; then
		eval "com_${VAR}_addr=$1; com_${VAR}_pid=$GLOBAL_PID"
		echo "SUCCESS: Saved state: Into variable '$VAR', address $1, PID $GLOBAL_PID"
	fi
}
purge_state() {
	if verify_name "$VAR"; then
		unset "com_${VAR}_addr" "com_${VAR}_pid"
	fi
}
load_state() {
	if verify_name "$VAR"; then
		eval "ADDR=\$com_${VAR}_addr"
		eval "PID=\$com_${VAR}_pid"
		if [ -z "$ADDR" ]; then
			echo "ILLEGAL VARIABLE: Name not found"
		else
			echo "SUCCESS: Loaded state: From variable '$VAR', address $ADDR, PID $PID"
		fi
	else
		ADDR=""; PID="$GLOBAL_PID"
	fi
	OFFSET=0
}

[ $# -ne 1 ] && show_usage
export PAGESIZE=$(getconf PAGESIZE)
export GLOBAL_PID="$1"
export CMD="" ORDER=""
export VAR="" DATA="" SIZE=""
export PID="" ADDR="" OFFSET="0"

trap 'exit' TERM INT

echo -n "PATCH> "
while read raw_cmd VAR data1 data2 data3 data4; do
	CMD="$(echo "$raw_cmd" | cut -d- -f1)"
	ORDER="$(echo "$raw_cmd" | cut -s -d- -f2)"
	ORDER="${ORDER:-s}"
	case $CMD in
		h|help) show_docs ;;
		a|attach) GLOBAL_PID="${VAR:-$GLOBAL_PID}" ;;
		m|maps)
			v_mode=""; v_name=""; v_size=""
			for opt in "$VAR" "$data1" "$data2"; do
				case $opt in
					m-*) v_mode="$(echo "$opt" | cut -d- -f2-)" ;;
					n-*) v_name="$(echo "$opt" | cut -d- -f2-)" ;;
					s-*) v_size="$(echo "$opt" | cut -d- -f2-)" ;;
				esac
			done
			while read -r e_addr e_mode e_ign e_ign e_ign e_name; do
				e_size="$(( 0x$(echo "$e_addr" | cut -d- -f2) - 0x$(echo "$e_addr" | cut -d- -f1) ))"
				e_addr="$(echo "$e_addr" | cut -d- -f1 | tr '[a-z]' '[A-Z]')"
				[ -n "$v_name" -a "$v_name" != "$e_name" ] && continue
				[ -n "$v_mode" -a "$v_mode" != "$e_mode" ] && continue
				[ -n "$v_size" -a "$((v_size))" -lt "$e_size" ] && continue
				echo "Address $e_addr; Size $(printf "%08x" $e_size); Mode $e_mode; Name $e_name"
			done <"/proc/$GLOBAL_PID/maps"
			;;
		f|find)
			PID="$GLOBAL_PID"
			DATA="$data1"
			OFFSET=0
			if [ -z "$data1" ]; then
				echo "ILLEGAL SYNTAX: Must have valid DATA field"
			else
				DATA="$(value_deorder | xxd -p -c0)"
				v_cand=""; v_mode=""; v_name=""; v_size="$((0xFFFFFF))"; v_ask=1
				for opt in "$data2" "$data3" "$data4"; do
					case $opt in
						m-*) v_mode="$(echo "$opt" | cut -d- -f2-)" ;;
						n-*) v_name="$(echo "$opt" | cut -d- -f2-)" ;;
						s-*) v_size="$(($(echo "$opt" | cut -d- -f2-)))"; v_ask=0 ;;
						sa-*) v_size="$(($(echo "$opt" | cut -d- -f2-)))" ;;
					esac
				done
				while read -r e_addr e_mode e_ign e_ign e_ign e_name; do
					e_size="$(( 0x$(echo "$e_addr" | cut -d- -f2) - 0x$(echo "$e_addr" | cut -d- -f1) ))"
					e_addr="$(echo "$e_addr" | cut -d- -f1 | tr '[a-z]' '[A-Z]')"
					[ -n "$v_name" -a "$v_name" != "$e_name" ] && continue
					[ -n "$v_mode" -a "$v_mode" != "$e_mode" ] && continue
					[ "$e_size" -gt "$v_size" ] && [ "$v_ask" -eq 0 ] && continue
					echo "Address $e_addr; Size $(printf "%08X" $e_size); Mode $e_mode; Name $e_name"
					[ "$e_size" -gt "$v_size" ] && ask_confirm "Long segment found. Do you still want to analyze?" <&3 && continue

					v_cand="${v_cand}$(dd if="/proc/$PID/pagemap" status=none bs=8 count=$((e_size / PAGESIZE)) skip=$((0x$e_addr / PAGESIZE)) | xxd -p -c8 -s7 | cut -c1 | {
						i_start=0; i_count=0;
						while read -r i_flag; do
							if [ "$((0x$i_flag))" -lt 8 ]; then
								if [ "$i_count" -gt 0 ]; then
							dd if="/proc/$PID/mem" status=none bs="$PAGESIZE" skip="$(( (0x$e_addr / PAGESIZE) + i_start ))" count="$i_count" | xxd -p -c0 | grep -F -abo "$DATA" | awk -v addr="$((0x$e_addr + ( PAGESIZE * i_start ) ))" 'BEGIN{FS=":"; print "obase=16;"} { printf "%s+(%s/2)\n", addr, $1 }' | bc | tr '\n' ' '
								fi
								i_start="$((i_start + i_count + 1))"
								i_count=0
							else
								i_count="$((i_count + 1))"
							fi
						done
						if [ "$i_count" -gt 0 ]; then
							dd if="/proc/$PID/mem" status=none bs="$PAGESIZE" skip="$(( (0x$e_addr / PAGESIZE) + i_start ))" count="$i_count" | xxd -p -c0 | grep -F -abo "$DATA" | awk -v addr="$((0x$e_addr + ( PAGESIZE * i_start ) ))" 'BEGIN{FS=":"; print "obase=16;"} { printf "%s+(%s/2)\n", addr, $1 }' | bc | tr '\n' ' '
						fi
					}) "
				done 3<&0 <"/proc/$PID/maps"
				while true; do
					echo "Have $(echo "$v_cand" | wc -w) candidates: $v_cand"
					echo -n "Enter a size and value for a direct pinpoint, or empty to abort: "
					read SIZE DATA && [ -n "$DATA" ] || break
					v_new_cand=""
					for ADDR in $v_cand; do
						ADDR="$(echo "$ADDR" | tr -d '\n ')"
						if read_pretty | grep -F -q "$DATA"; then
							v_new_cand="${v_new_cand}$ADDR "
						fi
					done
					v_cand=$v_new_cand
				done
				echo "Have $(echo "$v_cand" | wc -w) candidates: $v_cand"
				echo -n "Enter a size and value for reverse pinpoint, empty to abort, or a command (a/o/s): "
				if read SIZE DATA && [ -n "$SIZE" ]; then
					v_new_cand=""
					l_order=""
					if [ -z "$DATA" ]; then
						echo -n "Following command '$SIZE', now enter a size and value: " #TODO check command validity
						l_order="$SIZE"
						read SIZE DATA
					fi
					if [ -n "$DATA" ]; then
						for ADDR in $v_cand; do
							ADDR="$(echo "$ADDR" | tr -d '\n ')"
							if [ "$l_order" = "o" -o "$l_order" = "s" ]; then
								read_pretty | grep -F -q "$DATA" || continue
							fi
							if [ "$l_order" != "a" -a "$l_order" != "o" ]; then
								read_pretty
								ask_confirm "Should pinpoint?" && continue
							fi
							write_pretty
							if [ "$l_order" != "a" -a "$l_order" != "o" ]; then
								read_pretty
								ask_confirm "Was pinpoint successful?" && continue
							fi
							v_new_cand="${v_new_cand}$ADDR "
							[ -z "$l_order" -o "$l_order" = "s" ] && break;
						done
					fi
					v_cand=$v_new_cand
				fi
				save_list "$v_cand"
			fi
			;;
		l|loop)

			;;
		p|point) save_state "$data1" ;;
		v|view) load_state ;;
		s|set)
			load_state
			SIZE="$data1"
			DATA="$data2"
			OFFSET="${data3:-0}"
			[ -n "$data2" ] && write_pretty || echo "ILLEGAL SYNTAX: Must have valid SIZE and DATA fields"
			;;
		g|get)
			load_state
			SIZE="$data1"
			if [ "$ORDER" = "f" -o "$ORDER" = "file" ]; then
				DATA="$data2"
				OFFSET="${data3:-0}"
				[ -n "$data2" ] && read_pretty ||	echo "ILLEGAL SYNTAX: Must have valid SIZE and DATA fields"
			else
				OFFSET="${data2:-0}"
				[ -n "$data1" ] && read_pretty ||	echo "ILLEGAL SYNTAX: Must have valid SIZE field"
			fi
			;;
		*)
			echo "ILLEGAL COMMAND: $cmd isn't a recognised command"
			;;
	esac
	echo -n "PATCH> "
done
